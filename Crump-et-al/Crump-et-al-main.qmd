---
title: "Crump-et-al-main"
output: html_document
date: "2025-10-21"
---

```{r setup, echo=FALSE, warning=FALSE}
setwd("/Users/jacobogomezlandero/Documents/Notre Dame PhD/Coursework/Field courses/Expectations/Replications/Econ-70330/Crump-et-al")
library(readxl)
library(dplyr)

sce_13_16 <- read_excel("Data/sce_13-16.xlsx", skip=1) # 2013-2016
sce_17_19 <- read_excel("Data/sce_17-19.xlsx",skip=1) # 2017-2019
sce <- bind_rows(sce_13_16, sce_17_19) # bind
sce <- sce %>%
  filter(date >= 201306 & date <= 201907) # Sample period
rm(sce_13_16, sce_17_19) # remove subsamples
```

```{r Fit inflation histogram into beta distribution}

# lower and upper limits of bins (10 intervals)
bin_lower <- c(12, 8, 4, 2, 0, -2, -4, -8, -12, -Inf)
bin_upper <- c(Inf, 12, 8, 4, 2, 0, -2, -4, -8, -12)
bin_vars <- paste0("Q9_bin", 1:10)

# ---- Fitting helper ----
fit_beta <- function(probs, lower, upper, minx=-12, maxx=12){
  probs <- as.numeric(probs)/100
  probs[is.na(probs) | probs < 0] <- 0
  if(sum(probs)==0) return(rep(NA,4))
  probs <- probs / sum(probs)
  
  mids <- (lower + upper)/2
  finite_mids <- mids[is.finite(mids)]
  mids[is.infinite(lower)] <- min(finite_mids)-2
  mids[is.infinite(upper)] <- max(finite_mids)+2
  
  x <- rep(mids, pmax(1, round(probs*100)))
  # rescale to [0,1]
  x01 <- (x - minx)/(maxx - minx)
  fit <- try(suppressWarnings(fitdist(x01, "beta", method="mle")), silent=TRUE)
  if(inherits(fit,"try-error")) return(rep(NA,4))
  
  a <- fit$estimate["shape1"]
  b <- fit$estimate["shape2"]
  mean <- minx + (maxx - minx)*a/(a+b)
  var  <- (maxx - minx)^2 * (a*b)/(((a+b)^2)*(a+b+1))
  p1   <- minx + (maxx - minx)*qbeta(0.01, a, b)
  p99  <- minx + (maxx - minx)*qbeta(0.99, a, b)
  c(mean, var, p1, p99)
}

fit_one <- function(probs, lower, upper) {
  probs <- as.numeric(probs)/100
  probs[is.na(probs) | probs < 0] <- 0
  if(sum(probs)==0) return(rep(NA,4))
  probs <- probs / sum(probs)
  nz <- which(probs>0)

  ## Case 1: single bin → uniform
  if(length(nz)==1){
    a <- lower[nz]; b <- upper[nz]
    m <- (a+b)/2; v <- (b-a)^2/12
    q1 <- a + 0.01*(b-a); q99 <- a + 0.99*(b-a)
    return(c(mean=m,var=v,p1=q1,p99=q99))
  }

  ## Case 2: two adjacent bins → triangular
  if(length(nz)==2 && diff(nz)==1){
    a <- lower[nz[1]]; b <- upper[nz[2]]
    mode <- (a+b)/2
    m <- (a+b+mode)/3
    v <- (a^2 + b^2 + mode^2 - a*b - a*mode - b*mode)/18
    q1 <- a + (b-a)*sqrt(0.01/2)
    q99 <- b - (b-a)*sqrt(0.01/2)
    return(c(mean=m,var=v,p1=q1,p99=q99))
  }

  # Case 3: 3+ bins → Beta (MLE via fitdistrplus)
  res <- fit_beta(probs, lower, upper)
  return(res)
}

# ---- Apply to main dataframe ----
sce_fitted <- sce %>%
  rowwise() %>%
  mutate(stats = list(fit_one(c_across(all_of(bin_vars)), bin_lower, bin_upper))) %>%
  ungroup() %>%
  mutate(mean_infl = map_dbl(stats,1,.default=NA_real_),
         var_infl  = map_dbl(stats,2,.default=NA_real_),
         p1        = map_dbl(stats,3,.default=NA_real_),
         p99       = map_dbl(stats,4,.default=NA_real_))

# Trim inconsistent responses
sce_trimmed <- sce_fitted %>%
  filter(Q8v2part2 >= p1, Q8v2part2 <= p99)

# Check trimming rate
trim_rate <- 1 - nrow(sce_trimmed) / nrow(sce_fitted)
cat("Share trimmed:", round(trim_rate*100, 2), "%")

# Trim the top 5 % of variance from the fitted densities
var_cutoff <- quantile(sce_trimmed$var_infl, 0.95, na.rm = TRUE)
sce_trimmed <- sce_trimmed %>%
  filter(var_infl <= var_cutoff)

# Drop outliers in spending and income expectations
sce_trimmed <- sce_trimmed %>%
  filter(abs(Q25v2part2) <= 50) %>%                       # spending growth ≤ ±50 %
  filter(Q25v2part2 <= 100 ,
         Q25v2part2 >= -50,
         Q26v2part2 <= 50)                  # income between 0.5× and 2×


```


```{r Variables}
# Select variables

# Basic variables
#   Inflation point forecast (Q8v2part2)
#   Expected Real Consumption Growth
#     Point forecast of spending growth (Q26v2part2)
#     Density-implied mean expected inflation (previously computed)
#   Point forecast of Income Growth (Q25v2part2)
basic_vars <- c("cluster", "weight", 
                  "ExpSG", "ExpInfl", "ExpCG", 
                  "RExpIncG", "PointInfl")

# Control Variables: Demos
# Age (Q32)
# Married (Q38)
# Female (Q33)
# Hispanic (Q34)
# Race (Q35_i)
# Education (Q36)
# Residence variables (Q45new) [include? It's mostly NAs]
# Labor force status (HH2_i)
# Multiple jobs (Q11) [== 1 if n > 1]
demos <- c(
  "age_cat", "female", "married", "hispanic", "multiple_jobs", "high_numeracy",
  paste0("Q35_", 1:6),   # race dummies
  paste0("HH2_", 1:11)   # labor-force status dummies
)

sce_trimmed_ext <- sce_trimmed %>%
  dplyr::mutate(cluster = paste(date, userid, sep=""),
         ExpInfl = mean_infl,
         PointInfl = Q8v2part2,
         ExpSG = Q26v2part2,
         ExpIncG = Q25v2part2,
         RExpIncG = ExpIncG - ExpInfl,
         ExpCG = ExpSG - ExpInfl,
         age_cat = case_when(
          Q32 <= 40 ~ "≤40",
          Q32 >= 41 & Q32 <= 59 ~ "41–59",
          Q32 >= 60 ~ "≥60",
          TRUE ~ NA_character_
        ),
        age_cat = factor(age_cat, levels = c("≤40", "41–59", "≥60")),
         married  = ifelse(Q38 == 1, 1,
                      ifelse(Q38 == 2, 0, NA_real_)),
        female   = ifelse(Q33 == 1, 1,
                          ifelse(Q33 == 2, 0, NA_real_)),
        hispanic = ifelse(Q34 == 1, 1,
                          ifelse(Q34 == 2, 0, NA_real_)),
        multiple_jobs = case_when(
          is.na(Q11) ~ NA_real_,
          Q11 > 1 ~ 1,
          TRUE ~ 0
        ),
        # Count number of correct answers across the 5 numeracy questions
        num_correct = (
          (QNUM1 == 150) +
          (QNUM2 == 242) +
          (QNUM3 == 10)  +
          (QNUM5 == 10)  +
          (QNUM6 == 5)
        ),
        # Indicator for high numeracy: at least 4 correct
        high_numeracy = ifelse(is.na(num_correct), NA_real_,
                               ifelse(num_correct >= 4, 1, 0))
      )

# Control Variables: Het. Int. Rate
#   Ownership of Primary Residence (Q43)
#   Ownership of Other Homes (Q44)
# 1. Generate categorical ownership variables
sce_trimmed_ext <- sce_trimmed_ext %>%
  dplyr::mutate(
    # Q43 categorical: 0 if missing, 1 if ==1, 2 if ==2, 3 otherwise
    Q43_cat = case_when(
      is.na(Q43) ~ 0,
      Q43 == 1   ~ 1,
      Q43 == 2   ~ 2,
      TRUE       ~ 3
    ),

    # Q44 binary: 1 if ==1, 0 if ==2
    Q44_bin = case_when(
      Q44 == 1 ~ 1,
      Q44 == 2 ~ 0,
      TRUE     ~ NA_real_
    )
  )
# initialize a vector to store interaction variable names
HetIntR <- c()

# 2. Interact with demographic variables
for (v in demos) {
  newname <- paste0(v, "_x_Q43") # with Q43_cat
  sce_trimmed_ext[[newname]] <- interaction(sce_trimmed_ext[[v]], sce_trimmed_ext$Q43_cat, drop = TRUE)
  HetIntR <- c(HetIntR, newname)
}
for (v in demos) {
  newname <- paste0(v, "_x_Q44") # with Q44_bin
  sce_trimmed_ext[[newname]] <- interaction(sce_trimmed_ext[[v]], sce_trimmed_ext$Q44_bin, drop = TRUE)
  HetIntR <- c(HetIntR, newname)
}

sce_sub <- sce_trimmed_ext %>%
dplyr::select(all_of(basic_vars), all_of(demos), all_of(HetIntR))

```

```{r Table 3 Regressions, warning=FALSE}
library(AER)
library(sandwich)
library(lmtest)

# Helper function for 2SLS with many controls
iv_with_controls <- function(dep, endog_rhs, instr_rhs, data, wts = NULL) {
  f_main  <- reformulate(endog_rhs, response = dep)
  f_instr <- reformulate(instr_rhs)

  f_main_str  <- paste(deparse(f_main),  collapse = " ")
  f_instr_str <- paste(deparse(f_instr), collapse = " ")
  f_instr_str <- sub("^~\\s*", "", f_instr_str)

  iv_formula  <- as.formula(paste(f_main_str, "|", f_instr_str))

  ivreg(iv_formula, data = data, weights = data$weight)
}

#--- Column 1
m1 <- lm(ExpSG ~ ExpInfl + RExpIncG, data = sce_sub, weights = weight)

#--- Column 2
m2 <- lm(
  reformulate(
    c("ExpInfl", "RExpIncG", demos),  # all RHS variable names
    response = "ExpSG"                # LHS variable
  ),
  data = sce_sub,
  weights = weight
)

#--- Column 3
m3 <- lm(
  reformulate(
    c("ExpInfl", "RExpIncG", demos, HetIntR),  # all RHS variable names
    response = "ExpSG"                # LHS variable
  ),
  data = sce_sub,
  weights = weight
)

#--- Column 4
m4 <- ivreg(ExpSG ~ ExpInfl + RExpIncG | PointInfl + RExpIncG, 
               data = sce_sub, weights = weight)

#--- Column 5
m5 <- iv_with_controls(
  dep       = "ExpSG",
  endog_rhs = c("ExpInfl", "RExpIncG", demos),
  instr_rhs = c("PointInfl", "RExpIncG", demos),
  data      = sce_sub,
  wts       = weight
)

#--- Column 6
m6 <- iv_with_controls(
  dep       = "ExpSG",
  endog_rhs = c("ExpInfl", "RExpIncG", c(demos, HetIntR)),
  instr_rhs = c("PointInfl", "RExpIncG", c(demos, HetIntR)),
  data      = sce_sub,
  wts       = weight
)


#--- Formatting
models <- list(m1, m2, m3, m4, m5, m6)
modelsummary(models)


```

